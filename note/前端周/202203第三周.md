## react setState 是同步还是异步

_setState 是同步的还是异步的？为什么有时候可以及时拿到结果，有时候又不能及时拿到结果？_

事件情况

1. **钩子函数和合成事件中：**

在 react 的生命周期和合成时间中，react 仍然处于他的更新机制中，这时`isBranchUpdate`为 true。按上述过程，这时候无论调用多少次`setState`, 都不会执行更新，而是将要更新的`setState`存入`_pendingStateQueue` 将要更新的组件存入 `dirtyComponent`。
当上一次更新机制执行完毕，以生命周期为例，所有的组件，即最顶层组件`Didmount`会将`isBranchUpdate`设置为 false，这时候会执行直接积累的`setState`。

2. **异步函数和原生事件中**

由执行机制来看，`setState`本身又不是异步的。如果是在调用`setState`时，如果 react 处于更新的过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。
在生命周期，根据 JS 的异步机制，会将异步函数先暂存，等所有的同步代码执行完毕后在执行，`isBranchUpdate` 被设置为 false。这时在调用`setState` 即可立即执行更新，拿到更新结果。

3. **partialState 合成机制**

`_processPendingState`，这个函数用于合并 state 暂存队列，最后一个返回一个合并后的 state

```javascript

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

```

如果传入的是对象，很明显会被合并成一次。

```javascript
Object.assign(nextState, { index: state.index + 1 }, { index: state.index + 1 })
```

4. **componentDidMount 调用 setState**

_在 componentDidMount 中，你可以立即调用 setState(), 它将触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使 render() 将会被调用两次，用不也看不到中间状态。谨慎使用这一模式，因为它常导致性能问题。在多数情况下，你可以在 constructor 中使用赋值初始值来代替。_
不建议在 componentDidMount 直接调用`setState`。但是可以在调用接口的回调中去修改
`state`

5. **componentWillUpdate 和 componentDidUpdate**

这两个生命周期中不能直接调用`setState`。结果： 会导致死循环，导致程序崩溃。

## 前端原型

**prototype**
_每一个函数都有一个 prototype 属性， 函数的 prototype 属性指向了一个对象。这个对象正是调用该函数而创建的实例的原型。_
_**原型**_
_每一个 javaScript 对象（null）除外，在创建的时候就会与另一个对象关联，这个对象就是我们说的原型，每一个对象都回从原型中_`_继承_`_属性。_ \***\*proto\*\***
_ javascript 对象(对象) 除了 null, 都有一个属性，叫**proto**， 这个属性会指向该对象的原型。_

```javascript
function Person {}
const person = new Person()
person.__proto__ === Person.prototype
```

**constructor**
_每个原型都有一个 constructor 属性指向关联的构造函数。_

```javascript
function Person() {}

Person.prototype.constructor === Person
```

**原型链**
_相互关联的原型组成的链状结构就是原型链_

## instanceof 原理

含义: instanceof 用于判断实例是否属于这个构造函数。

对象的.**proto** 是否等于 target.prototype

```js
function instanceof(origin, target) {
  while(origin) {
    if (origin.__proto__ === target.prototype) {
      return true
    }
    origin = origin.__proto__
  }
  return false
}

```
