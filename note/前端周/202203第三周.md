## react setState 是同步还是异步

_setState 是同步的还是异步的？为什么有时候可以及时拿到结果，有时候又不能及时拿到结果？_

事件情况

1. **钩子函数和合成事件中：**

在 react 的生命周期和合成时间中，react 仍然处于他的更新机制中，这时`isBranchUpdate`为 true。按上述过程，这时候无论调用多少次`setState`, 都不会执行更新，而是将要更新的`setState`存入`_pendingStateQueue` 将要更新的组件存入 `dirtyComponent`。
当上一次更新机制执行完毕，以生命周期为例，所有的组件，即最顶层组件`Didmount`会将`isBranchUpdate`设置为 false，这时候会执行直接积累的`setState`。

2. **异步函数和原生事件中**

由执行机制来看，`setState`本身又不是异步的。如果是在调用`setState`时，如果 react 处于更新的过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。
在生命周期，根据 JS 的异步机制，会将异步函数先暂存，等所有的同步代码执行完毕后在执行，`isBranchUpdate` 被设置为 false。这时在调用`setState` 即可立即执行更新，拿到更新结果。

3. **partialState 合成机制**

`_processPendingState`，这个函数用于合并 state 暂存队列，最后一个返回一个合并后的 state

```javascript

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

```

如果传入的是对象，很明显会被合并成一次。

```javascript
Object.assign(nextState, { index: state.index + 1 }, { index: state.index + 1 })
```

4. **componentDidMount 调用 setState**

_在 componentDidMount 中，你可以立即调用 setState(), 它将触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使 render() 将会被调用两次，用不也看不到中间状态。谨慎使用这一模式，因为它常导致性能问题。在多数情况下，你可以在 constructor 中使用赋值初始值来代替。_
不建议在 componentDidMount 直接调用`setState`。但是可以在调用接口的回调中去修改
`state`

5. **componentWillUpdate 和 componentDidUpdate**

这两个生命周期中不能直接调用`setState`。结果： 会导致死循环，导致程序崩溃。

## 前端原型

**prototype**
_每一个函数都有一个 prototype 属性， 函数的 prototype 属性指向了一个对象。这个对象正是调用该函数而创建的实例的原型。_
_**原型**_
_每一个 javaScript 对象（null）除外，在创建的时候就会与另一个对象关联，这个对象就是我们说的原型，每一个对象都回从原型中_`_继承_`_属性。_ \***\*proto\*\***
_ javascript 对象(对象) 除了 null, 都有一个属性，叫**proto**， 这个属性会指向该对象的原型。_

```javascript
function Person {}
const person = new Person()
person.__proto__ === Person.prototype
```

**constructor**
_每个原型都有一个 constructor 属性指向关联的构造函数。_

```javascript
function Person() {}

Person.prototype.constructor === Person
```

**原型链**
_相互关联的原型组成的链状结构就是原型链_

## instanceof 原理

含义: instanceof 用于判断实例是否属于这个构造函数。

`对象的.__proto__`是否等于`target.prototype`

```js
function instanceof(origin, target) {
  while(origin) {
    if (origin.__proto__ === target.prototype) {
      return true
    }
    origin = origin.__proto__
  }
  return false
}

```

## apply 和 call 的作用及区别

片面理解：
作用： 改变 this 的指向。
区别： 传递参数不一样 `apply` 接收两个参数 ,第一个参数需要指向的对象，第二个数组。 `call`: 接收多个参数，第一个参数与 apply 一样，其他多个参数以,分隔传入。

比较正式理解：
定义： 能够改变函数的执行时的上下文，将一个对象的方法交给另外一个对象来执行，并且是立即执行的。

注意：调用 call 和 apply 的对象，必须是一个函数 Function

手写 apply

```js
function myApply(ctx, args) {
    ctx = ctx || windows
    const key = symbol()
    ctx[key] = this
    if (Array.isArray(args)) return new Error('apply第二个参数必须是数组')
    const result = ctx[key](...args)
    delete ctx[key]
    return result
}
```

## position 有哪些值，作用分别是什么

自己理解：
`realtive` `absoulte` `static` `fixed` `sticky` (理解 100%)

realtive: 相对自身定位
absolute: 绝对定位，绝对定位元素相对于最近的非 static 祖先元素定位。 (相对定位未脱离文档流，绝对定位脱离了文档流) 绝对定位不占空间。
static: 正常行为，默认值
fixed: 固定定位与绝对定位相似，但元素的包含块为 viewport 适口。
sticky: 粘性定位，可以被认为是相对定位和固定定位的混合。元素在跨越特定的阀值前为相对定位，之后为固定定位。必须与`top` `bottom` `left` `right` 之一搭配使用，才能生效。否则行为就与相对定位相同。
